# Dobot M1Pro新架構交握設計文檔

## 系統架構概述

新架構採用**混合交握協議**，將Flow分為兩大類別：
- **運動類Flow**: 採用狀態機交握協議，確保運動安全性
- **IO類Flow**: 採用專用佇列方式，支援併行執行

## 架構分類

### 運動類Flow (序列化執行)
| Flow | 功能 | 特性 |
|------|------|------|
| Flow1 | VP視覺抓取流程 | 機械臂運動 + CCD1視覺 + 夾爪控制 |
| Flow2 | CV出料流程 | 機械臂運動 + 夾爪控制 |
| Flow5 | 機械臂運轉流程 | 純機械臂運動控制 |

**特點**: 
- 使用狀態機交握協議
- 一次只能執行一個運動Flow
- 完整的Ready→Running→完成循環
- 基地址: 1200-1249

### IO類Flow (併行執行)
| Flow | 功能 | 特性 |
|------|------|------|
| Flow3 | 翻轉站控制 | 純IO操作，不涉及機械臂 |
| Flow4 | 震動投料控制 | 純IO操作，不涉及機械臂 |

**特點**:
- 使用專用佇列方式
- 可與運動Flow同時執行
- 簡化控制，直接指令觸發
- 控制地址: 447-449

## 寄存器地址映射

### 運動類狀態機 (基地址1200-1249)

#### 運動狀態寄存器 (1200-1219) - 只讀
| 地址 | 功能 | 數值定義 | 說明 |
|------|------|----------|------|
| 1200 | 運動狀態寄存器 | bit0=Ready, bit1=Running, bit2=Alarm, bit3=Initialized | 運動類Flow核心控制位 |
| 1201 | 當前運動Flow | 0=無, 1=Flow1, 2=Flow2, 5=Flow5 | 正在執行的運動Flow |
| 1202 | 運動進度 | 0-100百分比 | 當前運動Flow完成度 |
| 1203 | 運動錯誤碼 | 0=無錯誤, >0=錯誤類型 | 運動類錯誤資訊 |
| 1204 | Flow1完成狀態 | 0=未完成, 1=完成且角度校正成功 | Flow1真正完成標誌 |
| 1205 | Flow2完成狀態 | 0=未完成, 1=完成 | Flow2完成標誌 |
| 1206 | Flow5完成狀態 | 0=未完成, 1=完成 | Flow5完成標誌 |
| 1207 | 運動操作計數 | 累積成功次數 | 運動類統計資訊 |
| 1208 | 運動錯誤計數 | 累積錯誤次數 | 運動類統計資訊 |
| 1209 | 運動系統運行時間 | 分鐘數 | 運動類運行時間 |
| 1210-1219 | 保留狀態 | - | 未來擴展使用 |

#### 運動控制寄存器 (1240-1249) - 讀寫
| 地址 | 功能 | 數值定義 | 說明 |
|------|------|----------|------|
| 1240 | Flow1控制 | 0=清空, 1=啟動VP視覺抓取 | Flow1觸發控制 |
| 1241 | Flow2控制 | 0=清空, 1=啟動出料流程 | Flow2觸發控制 |
| 1242 | Flow5控制 | 0=清空, 1=啟動機械臂運轉 | Flow5觸發控制 |
| 1243 | 運動清除警報 | 0=無動作, 1=清除運動Alarm | 運動類錯誤重置 |
| 1244 | 運動緊急停止 | 0=正常, 1=緊急停止運動 | 運動類安全停止 |
| 1245-1249 | 保留控制 | - | 未來擴展使用 |

### IO類控制寄存器 (447-449) - 讀寫
| 地址 | 功能 | 數值定義 | 說明 |
|------|------|----------|------|
| 447 | Flow3控制 | 0=清空, 1=啟動翻轉站 | 翻轉站IO控制 (併行) |
| 448 | Flow4控制 | 0=清空, 1=啟動震動投料 | 震動投料IO控制 (併行) |
| 449 | 保留IO控制 | - | 未來IO Flow擴展 |

## 運動類狀態機邏輯

### 狀態位定義
```
地址1200的二進制位元控制:
bit0 = Ready      (運動系統準備就緒，可接受新運動指令)
bit1 = Running    (運動系統執行中，拒絕新運動指令)
bit2 = Alarm      (運動系統警報狀態，需要重置)
bit3 = Initialized (運動系統已完成初始化)
bit4-15 = 保留   (未來擴展使用)
```

### 狀態組合解讀
| 二進制 | 十進制 | Ready | Running | Alarm | 狀態說明 |
|--------|--------|-------|---------|-------|----------|
| 00001001 | 9 | 1 | 0 | 0 | 運動系統Ready，可接受運動指令 |
| 00001010 | 10 | 0 | 1 | 0 | 運動系統執行中，拒絕新運動指令 |
| 00001100 | 12 | 0 | 0 | 1 | 運動系統警報，需要重置 |
| 00001000 | 8 | 0 | 0 | 0 | 運動系統空閒，等待狀態更新 |

## 交握協議流程設計

### Flow1 (VP視覺抓取) - 運動類交握
```
1. PLC檢查: 讀取1200寄存器 = 9 (Ready=1)
2. PLC觸發: 寫入1240=1 (Flow1控制)
3. 系統響應: 1200寄存器 = 10 (Ready=0, Running=1)
4. 系統執行: 1201寄存器 = 1 (Flow1執行中)
5. Flow1完成:
   - 成功: 1200寄存器 = 8, 1204 = 1 (Flow1完成且角度校正成功)
   - 失敗: 1200寄存器 = 12 (Alarm=1)
6. PLC清零: 寫入1240=0
7. 系統恢復: 1200寄存器 = 9 (Ready=1)
```

### Flow2 (出料流程) - 運動類交握
```
前提條件: 1200寄存器bit0=1 (Ready=1) 且 1240=0 (Flow1控制已清零)

1. PLC檢查: 讀取1200寄存器 = 9 (Ready=1)
2. PLC觸發: 寫入1241=1 (Flow2控制)
3. 系統響應: 1200寄存器 = 10 (Ready=0, Running=1)
4. 系統執行: 1201寄存器 = 2 (Flow2執行中)
5. Flow2完成:
   - 成功: 1200寄存器 = 8, 1205 = 1 (Flow2完成)
   - 失敗: 1200寄存器 = 12 (Alarm=1)
6. PLC清零: 寫入1241=0
7. 系統恢復: 1200寄存器 = 9 (Ready=1)
```

### Flow5 (機械臂運轉) - 運動類交握
```
前提條件: 1200寄存器bit0=1 (Ready=1) 且其他運動控制已清零

1. PLC檢查: 讀取1200寄存器 = 9 (Ready=1)
2. PLC觸發: 寫入1242=1 (Flow5控制)
3. 系統響應: 1200寄存器 = 10 (Ready=0, Running=1)
4. 系統執行: 1201寄存器 = 5 (Flow5執行中)
5. Flow5完成:
   - 成功: 1200寄存器 = 8, 1206 = 1 (Flow5完成)
   - 失敗: 1200寄存器 = 12 (Alarm=1)
6. PLC清零: 寫入1242=0
7. 系統恢復: 1200寄存器 = 9 (Ready=1)
```

### Flow3 (翻轉站) - IO類併行控制
```
併行執行特性: 可與運動Flow同時執行，不受運動狀態機限制

1. PLC觸發: 寫入447=1 (Flow3控制)
2. 系統處理: 指令加入Flow3專用佇列
3. 異步執行: Flow3執行緒處理翻轉站IO操作
4. 完成清零: 系統自動清零447=0
5. 狀態獨立: 不影響運動類Flow的執行
```

### Flow4 (震動投料) - IO類併行控制
```
併行執行特性: 可與運動Flow同時執行，不受運動狀態機限制

1. PLC觸發: 寫入448=1 (Flow4控制)
2. 系統處理: 指令加入Flow4專用佇列
3. 異步執行: Flow4執行緒處理震動投料IO操作
4. 完成清零: 系統自動清零448=0
5. 狀態獨立: 不影響運動類Flow的執行
```

### 運動類警報處理流程
```
當1200寄存器bit2=1 (Alarm=1)時:
1. PLC檢測: 1200寄存器 = 12 (Alarm=1)
2. PLC重置: 寫入1243=1 (清除運動警報)
3. 系統清除: 1200寄存器bit2=0 (Alarm清除)
4. PLC確認: 寫入1243=0
5. 系統恢復: 1200寄存器 = 9 (Ready=1)
```

## 併行執行範例

### 場景1: 運動+IO併行
```
時間點T1: 執行Flow1 (運動類)
- 1200 = 10 (Running), 1201 = 1
- 同時可執行Flow3: 寫入447=1 (翻轉站併行)
- 同時可執行Flow4: 寫入448=1 (震動投料併行)

結果: Flow1專心處理機械臂運動，Flow3/4同時處理IO操作
```

### 場景2: 運動類序列化
```
時間點T1: Flow1執行中 (1200 = 10, 1201 = 1)
時間點T2: 嘗試啟動Flow2 (寫入1241=1)
結果: Flow2被拒絕，因為運動系統Running=1

正確流程:
1. 等待Flow1完成 (1200 = 8)
2. PLC清零Flow1 (1240=0)
3. 系統恢復Ready (1200 = 9)
4. 啟動Flow2 (1241=1)
```

## 錯誤觸發條件

### 運動類錯誤 (Alarm=1 @ 1200)
- 機械臂連接失敗
- 運動控制異常
- 點位不存在
- 夾爪操作失敗
- CCD檢測失敗
- 運動超時

### IO類錯誤 (佇列處理)
- IO設備通訊失敗
- 指令執行超時
- 設備狀態異常
- 佇列溢出

## 技術實現架構

### 運動類Flow執行緒 (Motion Thread)
```python
class MotionFlowThread:
    """運動類Flow統一執行緒，實現狀態機交握"""
    
    def __init__(self):
        self.motion_state_machine = MotionStateMachine(base_addr=1200)
        self.flow_executors = {
            1: Flow1VisionPickExecutor,
            2: Flow2UnloadExecutor, 
            5: Flow5AssemblyExecutor
        }
        
    def run(self):
        while self.running:
            # 檢查運動控制寄存器 1240-1242
            self.process_motion_commands()
            # 更新運動狀態機 1200-1219
            self.update_motion_status()
            time.sleep(0.05)  # 50ms循環
```

### 運動類狀態機寄存器映射
```python
class MotionRegisters:
    """運動類Flow寄存器映射 (基地址1200-1249)"""
    
    # 運動狀態寄存器 (1200-1219) - 只讀
    MOTION_STATUS = 1200          # 運動狀態寄存器
    CURRENT_MOTION_FLOW = 1201    # 當前運動Flow
    MOTION_PROGRESS = 1202        # 運動進度
    MOTION_ERROR_CODE = 1203      # 運動錯誤碼
    FLOW1_COMPLETE = 1204         # Flow1完成狀態
    FLOW2_COMPLETE = 1205         # Flow2完成狀態
    FLOW5_COMPLETE = 1206         # Flow5完成狀態
    MOTION_OP_COUNT = 1207        # 運動操作計數
    MOTION_ERR_COUNT = 1208       # 運動錯誤計數
    MOTION_RUN_TIME = 1209        # 運動系統運行時間
    
    # 運動控制寄存器 (1240-1249) - 讀寫
    FLOW1_CONTROL = 1240          # Flow1控制
    FLOW2_CONTROL = 1241          # Flow2控制
    FLOW5_CONTROL = 1242          # Flow5控制
    MOTION_CLEAR_ALARM = 1243     # 運動清除警報
    MOTION_EMERGENCY_STOP = 1244  # 運動緊急停止
```

### IO類Flow執行緒 (Dedicated Threads)
```python
class Flow3FlipStationThread:
    """Flow3專用執行緒，併行處理"""
    
    def run(self):
        while self.running:
            # 監控447寄存器
            command = self.check_control_register(447)
            if command:
                # 異步執行，不影響運動Flow
                self.execute_flip_station()

class Flow4VibrationFeedThread:
    """Flow4專用執行緒，併行處理"""
    
    def run(self):
        while self.running:
            # 監控448寄存器  
            command = self.check_control_register(448)
            if command:
                # 異步執行，不影響運動Flow
                self.execute_vibration_feed()
```

## 系統啟動順序

1. **啟動主Modbus TCP Server** (端口502)
2. **初始化運動類狀態機** (基地址1200)
3. **啟動運動類Flow執行緒** (處理Flow1/2/5)
4. **啟動IO類Flow執行緒** (處理Flow3/4)
5. **啟動狀態機交握循環** (50ms更新頻率)
6. **系統準備完成** (1200寄存器 = 9)

## PLC操作指南

### 運動類Flow操作

#### Flow1 VP視覺抓取
```
1. 檢查準備: 讀取1200 = 9 (Ready=1)
2. 啟動取料: 寫入1240 = 1
3. 監控執行: 讀取1200 = 10, 1201 = 1
4. 等待完成: 讀取1200 = 8, 1204 = 1
5. 清零指令: 寫入1240 = 0
6. 確認恢復: 讀取1200 = 9
```

#### Flow2 出料流程
```
前提: 1200 = 9 且 1240 = 0 (Flow1已完成且已清零)
1. 檢查準備: 讀取1200 = 9
2. 啟動出料: 寫入1241 = 1
3. 監控執行: 讀取1200 = 10, 1201 = 2
4. 等待完成: 讀取1200 = 8, 1205 = 1
5. 清零指令: 寫入1241 = 0
6. 確認恢復: 讀取1200 = 9
```

#### Flow5 機械臂運轉
```
前提: 1200 = 9 且其他運動控制寄存器已清零
1. 檢查準備: 讀取1200 = 9
2. 啟動運轉: 寫入1242 = 1
3. 監控執行: 讀取1200 = 10, 1201 = 5
4. 等待完成: 讀取1200 = 8, 1206 = 1
5. 清零指令: 寫入1242 = 0
6. 確認恢復: 讀取1200 = 9
```

### IO類Flow操作

#### Flow3 翻轉站 (併行)
```
1. 直接觸發: 寫入447 = 1
2. 系統處理: 自動加入Flow3佇列
3. 異步執行: 不阻塞運動Flow
4. 自動清零: 447自動變為0
5. 可重複: 隨時可再次觸發
```

#### Flow4 震動投料 (併行)
```
1. 直接觸發: 寫入448 = 1
2. 系統處理: 自動加入Flow4佇列
3. 異步執行: 不阻塞運動Flow
4. 自動清零: 448自動變為0
5. 可重複: 隨時可再次觸發
```

### 運動類警報處理
```
1. 檢測警報: 讀取1200 = 12 (Alarm=1)
2. 清除警報: 寫入1243 = 1
3. 確認清除: 讀取1200 = 9 (Alarm位清除)
4. 清零指令: 寫入1243 = 0
```

## 關鍵特點

### 架構優勢
1. **安全性**: 運動Flow使用嚴格的狀態機交握，確保機械臂安全
2. **效率性**: IO Flow採用併行執行，提高系統整體效率
3. **靈活性**: 混合架構兼顧安全與效率需求
4. **擴展性**: 運動類和IO類都可獨立擴展
5. **相容性**: 保持原有設備的通訊協議不變
6. **穩定性**: 地址分配避免模組間衝突

### 技術特點
1. **狀態隔離**: 運動狀態機與IO佇列完全獨立
2. **併行能力**: IO操作不影響運動Flow執行
3. **序列保證**: 運動Flow嚴格序列化，避免運動衝突
4. **錯誤隔離**: 運動錯誤與IO錯誤分別處理
5. **高響應**: 50ms狀態機循環，快速響應控制指令
6. **地址安全**: 地址範圍避開所有現有模組

### 應用場景
1. **純運動**: 僅執行Flow1/2/5，專注運動控制
2. **純IO**: 僅執行Flow3/4，專注IO操作
3. **混合作業**: 運動+IO併行，最大化系統利用率
4. **緊急處理**: 運動類支援緊急停止，IO類支援即時中斷

## 開發注意事項

### 運動類Flow開發
- 必須實現標準的狀態機交握介面
- 需要處理Ready/Running/Alarm狀態轉換
- 必須支援進度回報 (1202寄存器)
- 需要實現完成狀態標誌 (1204/1205/1206)
- 使用基地址1200-1249

### IO類Flow開發
- 使用專用佇列和執行緒
- 實現簡化的控制介面 (447/448寄存器)
- 支援併行執行，不阻塞其他Flow
- 需要自動清零控制寄存器

### 測試驗證
- 運動類Flow需要完整的交握協議測試
- IO類Flow需要併行執行測試
- 混合場景需要運動+IO同時執行測試
- 錯誤處理需要分類測試 (運動錯誤 vs IO錯誤)
- 驗證地址範圍1200-1249的讀寫權限
- 確認與其他模組無地址衝突

## 系統集成

### 外部模組依賴
- **CCD1視覺**: 基地址200，Flow1依賴視覺檢測
- **Gripper夾爪**: 基地址500，Flow1/2依賴夾爪控制
- **AngleHighLevel**: 基地址700，Flow1依賴角度校正
- **機械臂API**: 192.168.1.6，所有運動Flow核心依賴

### 通訊協議
- **主服務器**: 127.0.0.1:502 (Modbus TCP)
- **更新頻率**: 50ms狀態機循環
- **響應時間**: <100ms指令響應
- **併行度**: 運動Flow序列化，IO Flow併行化

### 資源管理
- **運動資源**: 獨佔式，同時只能一個運動Flow
- **IO資源**: 共享式，多個IO Flow可同時執行
- **記憶體管理**: 佇列大小限制，防止記憶體溢出
- **執行緒管理**: 專用執行緒池，資源隔離